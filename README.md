
<div align=center><a href="https://myseoulguide.site"><img src="https://user-images.githubusercontent.com/74864925/129395349-90ca9abc-6b1a-4989-b98a-aadfec7ff383.png"/></a></div>

# <div align=center>My Seoul Guide</div> 
#### <div align=center>This is for your trip, This is your Seoul.</div>

<br/>

<div align=center>
<img src="https://travis-ci.org/joemccann/dillinger.svg?branch=master"/>&nbsp;
  <img src="https://img.shields.io/github/stars/noah071610/My-Seoul-Guide?style=social"/>&nbsp;
  <img src="https://img.shields.io/github/watchers/noah071610/My-Seoul-Guide?style=social"/>&nbsp;
</div>

<br/>

<div align=center>
<img src="https://img.shields.io/badge/Photoshop-31A8FF?style=flat-square&logo=adobe-photoshop&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/HTML5-E34F26?style=flat-square&logo=HTML5&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/CSS3-1572B6?style=flat-square&logo=CSS3&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/SCSS-CC6699?style=flat-square&logo=Sass&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat-square&logo=JavaScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/TypeScript-3178C6?style=flat-square&logo=TypeScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/React-61DAFB?style=flat-square&logo=React&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/MobX-FF9955?style=flat-square&logo=MobX&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Emotion-DB7093?style=flat-square&logo=styled-components&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Antd-0170FE?style=flat-square&logo=Ant-design&logoColor=white"/>&nbsp; <br/>
<img src="https://img.shields.io/badge/Node.js-339933?style=flat-square&logo=node-dot-js&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/GraphQL-E434AA?style=flat-square&logo=GraphQL&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Apollo-311C87?style=flat-square&logo=Apollo-GraphQL&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Google_Map-4285F4?style=flat-square&logo=Google-Maps&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Babel-F9DC3E?style=flat-square&logo=Babel&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Webpack-8DD6F9?style=flat-square&logo=Webpack&logoColor=white"/>&nbsp;
  <img src="https://img.shields.io/badge/Amazon_AWS-232F3E?style=flat-square&logo=Amazon-AWS&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Linux-FCC624?style=flat-square&logo=Linux&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/NGINX-009639?style=flat-square&logo=NGINX&logoColor=white"/>&nbsp;
</div>

<br/>

<div align=center>
  <a href="https://github.com/noah071610" target="_blank"><img src="https://image.flaticon.com/icons/png/24/25/25657.png"/></a>&nbsp;
  <a href="https://www.instagram.com/salmonchobab" target="_blank"><img src="https://image.flaticon.com/icons/png/24/1409/1409946.png"/></a>&nbsp;
  <a href="https://velog.io/@noah071610" target="_blank"><img width="24" src="https://api.faviconkit.com/velog.io/144"/></a>&nbsp;
  <a href="mailto:noah071610@naver.com"><img src="https://image.flaticon.com/icons/png/24/552/552486.png"/></a>&nbsp;
  <a href=href="https://noahworld.site/portfolio" target="_blank"><img src="https://image.flaticon.com/icons/png/24/3135/3135715.png"/></a>&nbsp;
</div>

<br/>

<div align=center>
  <a href="https://myseoulguide.site"><img src="https://img.shields.io/badge/go_to_website-EFFDFF?style=for-the-badge"/>&nbsp;</a>
</div>

<br/><br/><br/><br/><br/>

## 🎉 YES, This is your Seoul.
#### 코로나라는 아픔을 이겨내고 한국에 다시 방문하게될 외국인들을 위한 웹 가이드 어플리케이션.
<br/>

> 🎤 : 마이서울가이드를 만든 이유가 뭔가요? 

2018년부터 2019년까지 개인적으로 서울에 오는 많은 외국인 관광객을 상대로 조사해본 결과

서울에는 볼거리가 넘쳐나 최적의 동선을 계획하는 것과 자신의 성향에 맞는 숙박 지역을

선택하는 데 많은 시간을 소비한다고 합니다. 저는 구글맵 API와 한국관광공사 OPEN API 그리고

고객에 성향에 맞춘 숙박 지역 추천 알고리즘을 자체적으로 만들어 이를 이용해 서울에 오는

외국인이 체계적으로 동선을 계획하고 편하게 관광할 수 있도록 이 웹앱 애플리케이션을

기획했습니다

<br/><br/>

## 🛫 Attention please, We will arrive in Incheon international Airport.
#### 프로젝트 기본 정보
<br/>

- 제작기간 : 2021/4 ~ 2021/6
- 개발자 : 장현수 (Noah) 외 0명
- 개발포지션 : 디자인 , 프론트엔드 , 백엔드 , 서버
- 언어 : English (日本語は間もなくアップデート予定です 🔜)
- 반응형 웹 사이트

<br/><br/>

## 🚝 Let's go into Center of Seoul.
#### 마이 서울 가이드의 기본적인 흐름에 대해서 리뷰해드리겠습니다.
<br/>

### 1. 이용자의 취향을 사전에 파악합니다.

![캡처_2021_06_04_00_49_56_718](https://user-images.githubusercontent.com/74864925/120674289-e937fe00-c4ce-11eb-9c8b-71c2d66d5017.png)
![캡처_2021_06_04_00_50_19_293](https://user-images.githubusercontent.com/74864925/120674297-eb01c180-c4ce-11eb-8929-0a2eec67bfb5.png)


```javascript
📁store.ts

const checkListStore = observable<CheckListStore>({
  // 체크된 모든 사항은 checkListStore 가 담당합니다.
  age: null,
  gender: null,
  party: null,
  purpose: [],
  // acm 은 accommodation의 약자입니다.
  acm: [],
  overlayCnt: 4,
  isSubmit: false,
  isPermanetSubmit: false,
  changeTaste: action((data: string[], name: string) => {
    if (name === "purpose") {
      checkListStore.purpose = data;
    } else {
      checkListStore.acm = data;
    }
  }),
  changeInfo: action((data: string, name: string) => {
    // 중복을 최소화 하기 위해 조건문을 활용하였습니다.
    if (name === "gender") {
      checkListStore.gender = data;
    } else if (name === "age") {
      checkListStore.age = data;
    } else {
      checkListStore.party = data;
    }
  }),
```
---

<br/>

### 2. 취향에 맞춘 숙박지역 및 명소 데이터를 가져옵니다.
- 이용자의 취향을 내장된 데이터를 토대로 분석해 점수를 매긴후 숙박지역 매칭순위 상위2개의 가져옵니다.
- 여기서 추천 명소를 위해 몇개의 항목을 따로 빼두는 작업을 거칩니다.

```javascript
📁store.ts

  onSubmit: action(() => {
    const map = new Map();
    const recommendsArr: string[] = [];
    //유저에게 받은 정보를 저장합니다.
    let userInfo = {
      //클라이언트에서 걸러주기때문에 typeScript에 !를 이용했습니다.
      gender: checkListStore.gender!,
      age: checkListStore.age!,
      party: checkListStore.party!,
      acm: [...checkListStore.acm],
      purpose: [...checkListStore.purpose],
    };

    //놀거리 추천에 이용할 항목과 특수키는 사전에 따로 분류합니다.
    for (const v of checkListStore?.purpose) {
      switch (v) {
        case "Food":
          recommendsArr.push(userInfo.purpose.splice(userInfo.purpose.indexOf(v), 1)[0]);
          break;
        case "Shopping":
          recommendsArr.push(userInfo.purpose.splice(userInfo.purpose.indexOf(v), 1)[0]);
          break;
        case "K-pop":
          recommendsArr.push(userInfo.purpose.splice(userInfo.purpose.indexOf(v), 1)[0]);
          break;
        case "Native Recommendation":
          userInfo.purpose.splice(userInfo.purpose.indexOf(v), 1);
          break;
        case "Plastic surgery":
          userInfo.purpose.splice(userInfo.purpose.indexOf(v), 1);
          break;
      }
    }

    //숙박 추천에 이용할 항목을 담습니다.
    let userPick = [...userInfo.purpose, ...userInfo.acm, userInfo.age];

    //숙박 추천에 관한 데이터를 ID와 value값으로 가져옵니다.
    const places = valueList.map((v) => {
      return { id: v.id, valueList: v.values.sort() };
    });

    //=========== Recommend Stay finder start =================

    // 해시맵과 그 메쏘드를 이용한 알고리즘입니다. 점수산출은 기존점수 나누기 이용자의 항목선택수 에 따릅니다.
    for (let i = 0; i < userPick.length; i++) {
      for (let j = 0; j < places.length; j++) {
        places[j].valueList.forEach((place) => {
          if (place.value === userPick[i]) {
            if (map.get(places[j].id)) {
              map.set(
                places[j].id,
                map.get(places[j].id) + Math.floor(place.rate / userPick.length)
              );
            } else {
              map.set(places[j].id, Math.floor(place.rate / userPick.length));
            }
          }
        });
      }
    }

    //분류를 위해 해시맵으로 되어있는 데이터를 다시 id와 cnt(획득점수)로 배열화하고 cnt순으로 내림차 정렬합니다.
    let rankPlace = Array.from(map, ([id, cnt]) => ({ id, cnt })).sort((a, b) => b.cnt - a.cnt);

    //===== special Key ======
    //이용자의 항목에 특수키가 있으면 rankPlace에서 순위 변경 작업이 일어납니다.
    //서울인들은 명동을 추천하지않습니다. 대체제도 많고요.  Native Recommendation 이라면 명동은 제외시켜버립니다.
    //서울 여러분은 명동을 추천하시나요?? 이견이 있으시면 언제든지 피드백 주세요.
    if (checkListStore.purpose.includes("Native Recommendation")) {
      rankPlace = rankPlace.filter((v) => v.id !== 1);
    }
    //강남은 성형에 성지입니다. 성형을 원한다면 강남의 순위를 맨위로 올립니다.
    if (checkListStore.purpose.includes("Plastic surgery")) {
      rankPlace.unshift(rankPlace.splice(rankPlace.map((v) => v.id).indexOf(3), 1)[0]);
    }

    //상위 두개만 추천할거기 때문에 상위 2곳에 값만 따로 때옵니다.
    let solution = rankPlace.slice(0, 2).map((v) => {
      return placeList[v.id - 1];
    });

    solution.forEach((v, i) => (v.point = rankPlace[i].cnt));

    //=================^^ Recommend Stay finder done. ^^=====================
```
---

<br/>

### 3. 사용법 안내 및 숙박지역 및 놀거리를 추천합니다.
- 모달은 overlay를 클릭시 사라지며 첫 시작시 한번만 나옵니다.
- 추천 숙박지역을 선택합니다. 이는 HOME 메뉴에 반영되고 Accomodation 메뉴에서 세부정보를 확인 할 수 있습니다.

<img src="https://user-images.githubusercontent.com/74864925/120071358-de91f900-c0c9-11eb-9785-232206427dec.gif"/>


```javascript
📁PlaceModal.tsx

<ul className="placeTags">
  {mainStore.userInfo?.purpose.concat(mainStore.userInfo?.acm).map((v, i) => (
    //추천 숙박지역 2곳과 점수를 나타내어 줍니다.
    <li className="tag" key={i}>
      {v}
    </li>
  ))}
</ul>
```
<br/>

- 추천 명소를 선택합니다. HOME 메뉴에 반영되고 삭제가능하며 Attractions 메뉴에서 추가 가능합니다.

![녹화_2021_06_04_00_58_13_751](https://user-images.githubusercontent.com/74864925/120675476-11742c80-c4d0-11eb-9c25-2696a083f73a.gif)

<br/>

```javascript
📁ActivityModal.tsx

export const ActivityModal = observer(() => {
  const onClickCard = useCallback((arg: TogoRecommedInter) => {
    //추천 놀거리를 클릭하면 메인페이지의 구글맵에 반영되게 합니다.
    const form = {
      path: { lat: parseFloat(arg.mapy._text), lng: parseFloat(arg.mapx._text) },
      title: arg.title._text,
      contentid: arg.contentid._text,
    };
    if (mainStore.togoLists.find((togo) => togo.contentid === form.contentid)) {
      //만약 이미 체크한 상태에서 다시 클릭한다면 리스트에서 삭제합니다.
      mainStore.deleteTogoList(form.contentid);
    } else {
      mainStore.addTogoList(form);
    }
  }, []);
  const { loading, error, data } = useQuery(GET_RECOMMEND, {
    variables: {
      ...
    },
  });
  
  return (
  
    ...
    
    <div className="recommend_container">
        {useSortList({ data: data, isKpop: mainStore.userInfo?.purpose.includes("K-pop") })?.map(
          (v: TogoRecommedInter, i: number) => (
            <div key={i} onClick={() => onClickCard(v)} className="recommend_card">
              <img
                className="recommend_img"
                src={v.firstimage?._text || NO_IMAGE_URL}
                alt={v.firstimage?._text || "no_image"}
              />
              <h4>{v.title._text}</h4>
              {mainStore.togoLists.find((togo) => togo.contentid === v.contentid._text) && (
                <img
                  alt="checked"
                  className="recommend_checked"
                  src="https://img.icons8.com/emoji/48/000000/check-box-with-check-emoji.png"
                />
              )}
            </div>
          )
        )}
      </div>
      
      ...
      
```

<br/>

- 추천 숙박 지역은 서버안 데이터를 통해서 분석하며, 추천 명소는 GraphQL과 공공데이터를 이용해 분석합니다.

<br/>

```javascript
📁server/db.ts
const getActivities = async (typeNum: number, pageNum: number) => {
  const contents = await fetch(
    `http://api.visitkorea.or.kr/openapi/service/rest/EngService/
    areaBasedList?ServiceKey=${process.env.TOUR_SERVICE_KEY}....`
  )
    .then((res) => res.text())
    .then((data) => {
      // XML을 JSON으로 바꿔줍니다. xml2json 라이브러리를 사용했습니다.
      let contents = JSON.parse(convert.xml2json(data, { compact: true })).response.body.items;
      return contents;
    });
  // 명소에대한 설명은 content id가 필요해 다시 요청을 보내는 것 말고는 방법이 없었습니다.
  for (let i = 0; i < contents.item.length; i++) {
    const getOneOverview = await fetch(
      `http://api.visitkorea.or.kr/openapi/service/rest/EngService/detailCommon.....
    )
      ...
      
    contents.item[i].overview = getOneOverview;
  }
  return contents.item;
};

📁server

  ...
  
  type Query {
    ActivityCards(typeNum: Int!, pageNum: Int!): [ActivityObj]
    FoodRecommendCards(isFood: Boolean!): [RecommendObj]
    ShoppingRecommendCards(isShopping: Boolean!): [RecommendObj]
    NearRecommendCards(mapx: Float!, mapy: Float!): [RecommendObj]
  }
`;

//서버에 그래프큐엘을 이용합니다.
const server = new ApolloServer({ typeDefs, resolvers });
server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});

```

---

<br/>

### 4. HOME에는 지정 숙소 및 가고싶은 명소의 내용이 담겨있습니다.
- 지정 숙박지역으로 부터 선택 명소까지의 경로를 탐색할 수 있습니다.
- 지정 숙박지역은 Accommodation 메뉴에서 변경 가능합니다.
- 지정 명소는 삭제 가능하며, Attractions 메뉴에서 추가 가능합니다 (Attractions 메뉴는 초기의 추천기반이아닌 한국관광공사의 인기+카테고리 기반입니다.)

<br/>

<img src="https://user-images.githubusercontent.com/74864925/120071700-6f1d0900-c0cb-11eb-908a-7b06207d4910.gif"/>

<br/>

```jsx
📁Home.tsx

      ...

      <LoadScript googleMapsApiKey={process.env.REACT_APP_MAP_CLIENT_ID as string}>
            <GoogleMap
              mapContainerStyle={mapContainerStyle}
              center={
              // 숙박지역이 정해져있지 않다면 서울의 정중앙을 center 좌표로 삼습니다.
                mainStore.place?.stationPath || { lat: 37.549687466128496, lng: 126.9809660539474 }
              }
              zoom={12}
            >
              {mainStore.place && (
                <OverlayView
                  position={mainStore.place?.stationPath}
                  mapPaneName={OverlayView.OVERLAY_MOUSE_TARGET}
                >
                  <Preview>
                    <h3>Your base place</h3>
                    <h4>{mainStore.place?.title._text}</h4>
                    <span>🌟</span>
                  </Preview>
                </OverlayView>
              )}
              {mainStore.togoLists.length > 0 &&
                mainStore.togoLists.map((v, i) => {
                  return (
                    <OverlayView
                      key={i}
                      position={v.path}
                      mapPaneName={OverlayView.OVERLAY_MOUSE_TARGET}
                    >
                      <Popover content={() => togoPopup(v.contentid, v.path)}>
                        <Preview>
                          <h3>List No.{i + 1}</h3>
                          <h4>{v.title}</h4>
                          <span>📍</span>
                        </Preview>
                      </Popover>
                    </OverlayView>
                  );
                })}
              {toPlacePath && (
                // Direction 부분은 코드량이 길어져서 따로 별개의 컴포넌트를 분리해두었습니다.
                <Directions origin={mainStore.place?.stationPath} destination={toPlacePath} />
              )}
            </GoogleMap>
          </LoadScript>
          
```
---

<br/>

### 5. HOME 이외 메뉴는 Accommodation / Airport / Attractions / Analyzer 가 있습니다. 
- 지정 숙박지역은 Accommodation 메뉴에서 확인 및 변경 가능합니다.

<img src="https://user-images.githubusercontent.com/74864925/120072235-c623dd80-c0cd-11eb-8e7a-251de91926e8.gif"/>

<br/>

- 공항에서 숙박지역까지의 경로를 Airport 메뉴에서 탐색합니다.

<img src="https://user-images.githubusercontent.com/74864925/120072242-cb812800-c0cd-11eb-87de-404af622344c.gif"/>

<br/>

```javascript
📁MapPage.tsx

const AcmAndRoutePage: FC = observer(() => {
  const { path } = useRouteMatch();
  // useRouteMatch 로 현재가 Accommodation 메뉴인지 Airport 메뉴인지 파악합니다.
  let isAirportRoutePath = path.slice(1) === "airport_route";
  const [center, setCenter] = useState<PathObj>({
    lat: 37.517146640932296,
    lng: 126.80792769408053,
  });

  useEffect(() => {
    if (!isAirportRoutePath && mainStore.place) {
      let centerXY = useCalcCenter(mainStore.place?.path as PathObj[]);
      //doubleCheck
      setCenter(centerXY);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAirportRoutePath, mainStore.place]);

  return (
    <MainPageWrapper>
      <LoadScript googleMapsApiKey={process.env.REACT_APP_MAP_CLIENT_ID as string}>
        <GoogleMap
          mapContainerClassName={isAirportRoutePath ? "map_route" : "map_acm"}
          center={center}
          zoom={isAirportRoutePath ? 10 : 13}
        >
          {isAirportRoutePath ? (
            //You can see direction when you pick airport up
            mainStore.airport && (
              <Directions
                origin={{
                  lat: mainStore.airport.path.lat,
                  lng: mainStore.airport.path.lng,
                }}
                destination={{
                  lat: mainStore.destination?.stationPath.lat,
                  lng: mainStore.destination?.stationPath.lng,
                }}
              />
            )
          ) : (
            //Polygon map area for acm page
            <Polygon paths={mainStore?.place?.path} options={polygonOption} />
          )}
        </GoogleMap>
      </LoadScript>
      {isAirportRoutePath ? (
        <AirportRouteCards />
      ) : (
        mainStore.place && <PlaceCards card={mainStore.place} isAcmCard={true} />
      )}
    </MainPageWrapper>
  );
});

export default AcmAndRoutePage;

```

- 놀거리 추가 및 탐색은 Attractions 메뉴에서 가능합니다.

![111](https://user-images.githubusercontent.com/74864925/129363658-81953b0a-5d19-4c27-9b0d-e2db9116d637.gif)

<br/>

```javascript
📁ActivityContent.tsx

const ActivityContent = () => {
  const [pageNumber, setPageNumber] = useState<number>(1);
  const [pageType, setPageType] = useState<number>(76);
  const router: any = useRouteMatch();
  useEffect(() => {
    //router.params의 값에 따라 보여주는 데이터를 변경합니다.
    const category = router.params.category;
    if (category === "popular") {
      setPageType(85);
    } else if (category === "facilities") {
      setPageType(78);
    } else if (category === "experience") {
      setPageType(76);
    }
    setPageNumber(1);
  }, [router]);

  const onClickNext = useCallback(() => {
    setPageNumber((prev) => ++prev);
  }, []);
  const onClickPrev = useCallback(() => {
    setPageNumber((prev) => --prev);
  }, []);

  const { loading, error, data } = useQuery(GET_CONTENTS, {
    variables: {
      pageNumber,
      pageType,
    },
  });
  if (loading) return <LoadingPage />;
  if (error) return <p className="error">Error :(</p>;

  return (
    <MainPageWrapper>
      {data.ActivityCards.map((card: ContentCardInter, i: number) => {
        return <ContentCard key={i} card={card} />;
      })}
      <Pagenation>
        {pageNumber === 1 ? (
        //페이지장수가 첫번째면 더이상 이전으로 갈 곳이 없기때문에 이전페이지버튼을 막아둡니다.
          <span className="btn-none">
            <DoubleLeftOutlined />
            Previous Page
          </span>
        ) : (
          <button onClick={onClickPrev} className="btn-prev btn-underLine">
            <DoubleLeftOutlined />
            Previous Page
          </button>
        )}
        <button onClick={onClickNext} className="btn-next btn-underLine">
          Next Page
          <DoubleRightOutlined />
        </button>
      </Pagenation>
    </MainPageWrapper>
  );
};

export default ActivityContent;
```

<br/>

### Analyzer 페이지에서 예산과 지출을 파악할 수 있습니다.
- 먼저 예산을 입력하고 지출을 기록합니다.

![녹화_2021_06_04_01_47_37_626](https://user-images.githubusercontent.com/74864925/120683031-1b9a2900-c4d8-11eb-8477-036162f00114.gif)

- 파이차트를 확인하며 지출비율, 남은예산 등을 파악합니다.

![222](https://user-images.githubusercontent.com/74864925/120682796-d7a72400-c4d7-11eb-8188-19cdc99c7e50.gif)

```javascript
📁LedgerModal.tsx

const LedgerModal = observer(
  ({ currentExchage, isModalVisible, setIsModalVisible }: AnalyzerContentProps) => {
    const [memo, onChangeMemo, setMemo] = useInput("");
    const [payment, onChangePayment, setPayment] = useInput(null);
    const [select, setSelect] = useState("");
    const onChangeSelect = useCallback((value: string) => {
      setSelect(value);
    }, []);

    const onSubmit = useCallback(() => {
      //입력을 안한 부분이 있다면 요청을 취소합니다.
      if (!payment || !select) {
        message.error("Please fill contents up");
        return;
      }
      // 날짜를 위한 데이터를 만듭니다.
      const date = new Date();
      const year = date.getFullYear();
      const month = ("0" + (1 + date.getMonth())).slice(-2);
      const day = ("0" + date.getDate()).slice(-2);
      let form = {
        date: year + "/" + month + "/" + day,
        type: select,
        // 환율정보를 제공하는 API를 이용하여 USD 를 KRW로 변환합니다.
        // 환율api https는 유료로만 제공하고 요청한도도 매우 야박해서 손절하고 1 USD = 1300 KRW 고정값을 넣었습니다 
        // 만약 추후에 필요하다면 유료결제해서 사용하겠습니다... (2021/06/04)
        payment: useExchageClac(payment, currentExchage),
        memo,
      };
      // 데이터를 store에 전달합니다.
      analyzerStore.addPaymentList(form);
      setMemo("");
      setPayment("");
    }, [currentExchage, memo, payment, select, setMemo, setPayment]);

    return (
      <LedgerModalComponent
        title="Ledger"
        visible={isModalVisible}
        onCancel={() => setIsModalVisible(false)}
        footer={false}
        className="analyzer_input"
      >
      
      ....
      
```

<br/><br/><br/>

## 🎯 What made you to go Seoul?

<br/>

> 🎤 : GraphQL 어떤가요?

RestAPI의 오버패칭과 언더패칭문제가 한국관광공사 OPEN API에서 정말 치명적이었습니다. 이런 치명적인 단점을 GraphQL이 효율적으로 개선시켜줬기 때문에 매우 만족하지만, Express 와 NestJS보단 익숙하지 않기 때문에 공부가 더욱더 필요합니다.

<br/>

> 🎤 : 지도관련 라이브러리는 어떤게 좋나요?

네이버맵과 카카오맵은 영어를 지원하지 않고 구글은 영어를 지원합니다. 그러나 대한민국이 국가보안 문제로 구글에 세부적인 지도내용을 공개하지 않기에 라이브러리 선정이 골치 아팠습니다. 고민 끝에 프로젝트의 정체성이 외국인에게 서울을 소개하는 영어로만 이루어진 프로젝트이기에 영어를 지원하는 구글맵을 선택했습니다. 차기프로젝트인 'Fall IN Asia' 에서는 이용이 간편하고 API 한도 제약이 거의 없는 우버의 MapBox를 사용했습니다.

<br/>

> 🎤 : Redux VS MobX

MobX의 경우에는 보다 로직이 간단하지만 Redux같은 경우엔 DevTool이 매우 직관적이고 강력하며 Saga 나 Thunk 같은 라이브러리를 같이 이용하면 시너지가 어마어마합니다. 간단한 프로젝트엔 MobX를, 대규모나 실무에선 Redux가 적합한거 같습니다. 둘다 훌륭한 상태관리 라이브러리입니다. 차기프로젝트인 'Fall IN Asia' 에서는 강력한 Data Fetching 라이브러리인 SWR과 Redux의 무거움을 덜어주는 Redux-toolkit을 혼용해서 사용했습니다.



<br/><br/><br/>

## 🎯 Why pronunciation of Seoul is similar to Soul?

<br/>

> 🎤 : 개발과정 중 힘들었던 부분과 피드백은?

<br/>

- API 요청은 돈이다 라는것을 몸소 체험했습니다. 요청 한도초과되서 당황했던 기억이 납니다.

![image](https://user-images.githubusercontent.com/74864925/120048788-0a25cc80-c053-11eb-8749-f398b4a68d6f.png)

- Emotion 라이브러리로 인해 CRA에 기본설정을 해체하는데 시간이 걸렸고 대신 CRA의 장단점및 craco 사용법을 알게 되었습니다.

- 메뉴(navigation)가 그렇게 중요한 컴포넌트가 아닌데도 불구하고 세세한 부분에도 심혈을 기울이다보니 상당히 로직이 복잡해지고 시간도 오래 걸리게 되었습니다. 차기 프로젝트 'Fall In Asia'에서는 로직과 컴포넌트의 중요성을 따져 시간을 할애하도록 노력했습니다.

- 최대한 컴포넌트의 재사용성을 위해서 힘썼지만 복잡한 로직에 가독성도 떨어지게 되었습니다. 그냥 컴포넌트 하나 더 만드는게 여러모로 나을듯 한데 욕심 부린것 같습니다. 차기 프로젝트 'Fall In Asia'에서는 기획초기에 투박하지만 스케치로 와이어프레임을 그리며 미리 계획적으로 컴포넌트를 분리했습니다.

- SCSS를 사용할건지 CSS-in-JS 를 사용할건지 선택해야되는데 애매하게 둘다 사용해 효율이 떨어졌습니다. 또한 클래스명 작명이 힘들었고 따라서 협업시 코딩컨벤션을 잘 따라야할 필요성을 느꼈습니다. 이후 차기 프로젝트 'Fall IN Asia' 에서 Emotion에 TailWindCSS를 넣어 CSS-in-JS만 사용했습니다.

![image](https://cdn-images-1.medium.com/max/1000/1*yBxZo9LNEjRaL7eKUBqRSA.png)

- 테스트를 피차일반 뒤로 미루며 생긴 예기치않은 오류에 많이 시간을 뺏겼습니다. 테스트 주도 개발 (TDD) 의 필요성을 느꼈고 차기 프로젝트 'Fall IN Asia' 에서 Jest와 Supertest등을 사용해서 V모델 개발을 최대한 인용해 단위테스트 와 통합테스트 (+인수테스트)를 시행했습니다.

- 모바일에서 불편한 사용감을 느꼈습니다 인수테스트중 "여행다닐때 노트북 별로 안쓰지 않아?" 라는 말이 상당히 와닿았고 현재 PWA를 공부중입니다.

<br/><br/><br/>

## 🌇 Before you go back your place from Seoul.

<br/>

> 🎤 : 구경갈래요!

#### <a href="https://myseoulguide.site">마이서울가이드 바로가기</a>

<br/>

> 🎤 : 업데이트 상황을 알려주세요

<br/>

| Date | Version | Update |
| ------ | ------ | ------ |
| 2020/06/04 | v1.0 | Final Update for first deployment through AWS |
| 2020/08/13 | v1.1 | Optimizated Components ,Stylesheet and Rebuild Attraction page  |

<br/>

> 🎤 : 마지막으로 하고 싶은말은?

<br/>

피드백은 항상 저를 성장시키게 합니다.

궁금한게 있으시면 noah071610@naver.com 으로 언제든지 편하게 연락주세요.

지금까지 신뢰를 주는 장현수였습니다. 긴글 읽어주셔서 감사합니다.


<br/><br/><br/>
